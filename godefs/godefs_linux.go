// Copyright Â© 2016-2022 Platina Systems, Inc. All rights reserved.
// Use of this source code is governed by the GPL-2 license described in the
// LICENSE file.

// Package godefs generates GO defintions from scsi C include files.
package main

//go:generate go run .

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
)

var (
	pad   = regexp.MustCompile("Pad_cgo[A-Za-z0-9_]*")
	snake = regexp.MustCompile("[ \t][A-Z][a-z0-9]*_[a-z0-9_]*")
)

func main() {
	for _, dn := range []string{"scsi", "sg", "bsg"} {
		if err := godef(dn); err != nil {
			fmt.Fprintln(os.Stderr, "godefs:", err)
			os.Exit(1)
		}
	}
}

func godef(dn string) error {
	const ifn = "types_linux.go"
	const ofn = "z" + ifn
	ipn := filepath.Join(dn, ifn)
	opn := filepath.Join(dn, ofn)
	args := []string{"go", "tool", "cgo", "-godefs", ipn}
	data, err := exec.Command(args[0], args[1:]...).Output()
	if err != nil {
		return fmt.Errorf("%v: %w", args, err)
	}
	for l := 0; l < 2; l++ {
		if i := bytes.IndexRune(data, '\n'); i > 0 {
			data = data[i+1:]
		}
	}
	data = pad.ReplaceAll(data, []byte("_"))
	data = snake.ReplaceAllFunc(data, func(src []byte) []byte {
		res := make([]byte, 0, len(src))
		x := false
		for _, b := range src {
			if x {
				if 'a' <= b && b <= 'z' {
					b = (b - 'a') + 'A'
				}
				res = append(res, b)
				x = false
			} else if b != '_' {
				res = append(res, b)
			} else {
				x = true
			}
		}
		return res
	})
	data, err = format.Source(data)
	if err != nil {
		return err
	}
	f, err := os.Create(opn)
	if err != nil {
		return err
	}
	defer f.Close()
	fmt.Fprintln(f, "// Code generated by scsi_id/godefs; DO NOT EDIT.\n")
	f.Write(data)
	return nil
}
